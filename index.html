<html>
<head>
<script src="three.min.js"></script>
<style>
  body, canvas {
    padding: 0;
    margin: 0;
  }
</style>
</head>
<body id="body">

Change the cube texture:
<input class="file-picker" type="file" id="imageupload" onchange="uploadImage(this)" name="bok" accept="image/*">
<input type="button" value="Download a Screenshot" onclick="downloadScreenshot()"/>
<input type="button" value="Start" onclick="start()"/>
<input type="button" value="Stop" onclick="stop()"/>

<script>
  let  scene;
  let  camera;
  let  renderer;
  let  geometry;
  let  material;
  let  mesh;
  let  running = false;
  let  texloader = new THREE.TextureLoader();

  // initialize 3D scene
  function init() {
    let materials = [
      new THREE.MeshLambertMaterial({ color: 0xffffff, map: texloader.load( 'mantis.png' ) }),
      new THREE.MeshLambertMaterial({ color: 0xffffff, map: texloader.load( 'bobross.png' ) }),
      new THREE.MeshLambertMaterial({ color: 0xffffff, map: texloader.load( 'darthavatar.png' ) }),
      new THREE.MeshLambertMaterial({ color: 0xffffff, map: texloader.load( 'feedback.png' ) }),
      new THREE.MeshLambertMaterial({ color: 0xffffff, map: texloader.load( 'alert.png' ) }),
      new THREE.MeshLambertMaterial({ color: 0xffffff, map: texloader.load( 'mantis.png' ) }),
    ];

    scene = new THREE.Scene();
    //scene.background = new THREE.Color( 0xaaaaaa );

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
    camera.position.z = 1000;

    geometry = new THREE.BoxGeometry(200, 200, 200);
    //material = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
    material = materials;

    mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    //var pointLight = new THREE.PointLight( 0xffffff, 1, 0, 2 );
    //pointLight.position.set( 2, 2, 450 );
    //this.scene.add( pointLight );
    scene.add(new THREE.AmbientLight(0xffffff));

    renderer = new THREE.WebGLRenderer({ alpha: true }); // alpha transparency...
    renderer.setClearColor( 0xffffff, 0 ); // second param is opacity, 0 => transparent
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // start the draw loop
  function start() {
    if (running)
      return;
    body.appendChild(renderer.domElement);
    running = true;
    render();
  }

  // stop the draw loop
  function stop() {
    if (!running)
      return;
    running = false;
    body.removeChild(renderer.domElement);
  }

  // computation
  function update() {
    mesh.rotation.x += 0.01;
    mesh.rotation.y += 0.02;
  }

  // draw loop (self calls when running = true, stops when running = false)
  function render() {
    if (!running)
      return;
    requestAnimationFrame( () => render() );
    update();                       // always do computation first...
    renderer.render(scene, camera); // then render result
  }

  // change texture map on the cube faces
  function uploadImage( e ) {
    if (imageupload.files && imageupload.files[0]) {
      let reader = new FileReader();
      reader.onload = function (e) {
        //image.src = e.target.result;// preview image, needs <img id="image">
        material.forEach( r => { r.map = texloader.load( e.target.result ); r.needsUpdate = true; } );
      };
      reader.readAsDataURL(imageupload.files[0]);
    }
  }

  // utility to download any image uri (including data buffer that <input> upload form gives us)
  function downloadURI(uri, name) {
    var link = document.createElement("a");
    link.download = name;
    link.href = uri;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    delete link;
  }

  // download a screenshot of the current canvas
  function downloadScreenshot() {
    renderer.render(scene, camera);
    let imgData = renderer.domElement.toDataURL();
    downloadURI(imgData, "screenshot.png");
  }

// start the sim
init();
start();
</script>

  </body>
</html>
